<link rel="import" href="elements/dynamic-form/dynamic-subcontact-type-selector.html">
<link rel="import" href="elements/pdf-element/pdf-element.html">

<dom-module id="ht-upload-dialog">
    <template>
        <style>
            .buttons {
                display: flex;
                justify-content: flex-start;
                box-sizing: border-box;
            }

            #form-buttons {
                justify-content: flex-end;
            }
            #scan-button {
                justify-content: flex-start;
                text-transform: capitalize;
            }
            #scan-button .modal-button {
                min-width: 0px;
            }

            #scan-button .modal-button[disabled] {
                --paper-button-ink-color: var(--app-background-color-dark);
                background-color: var(--app-background-color-dark);
            }

            #upload-button {
                justify-content: flex-start;
                text-transform: capitalize;
            }
            paper-dialog {
                min-width: 1024px;
                margin: 0;
                display: flex;
                height: 80%;
                min-height: 400px;
                --main-height: 80vh;
            }

            #drag-drop-layer {
                position: absolute;
                height: 100%;
                width: 100%;
                top: 0;
                left: 0;
                margin: 0;
                padding: 0;
                background-color: rgba(0, 0, 0, .3);
                visibility: hidden;
            }

            #form {
                flex-grow: 1;
                margin-bottom: 20px
            }

            .input-form {
                width: 100%;
                height: 40px;
                display: flex;
                flex-direction: row;
            }

            vaadin-upload {
                border: none;
                padding: 0;
                --vaadin-upload-button-add: {
                    background: var(--app-secondary-color);
                    color: var(--app-text-color);
                    height: 40px;
                };

                --vaadin-upload-file-progress: {
                    display: none;
                    --paper-progress-active-color: var(--app-secondary-color);
                };
                --vaadin-upload-file-commands: {
                    display: none;
                    color: var(--app-primary-color);
                };
                --vaadin-upload-drop-label: {
                    display: none;
                }
            }

            vaadin-combo-box {
                --vaadin-combo-box-overlay-max-height: 30vh;
            }

            vaadin-text-field {
                height: 40px;
                margin-top: -16px;
            }

            #importTextField, #hcpCombo, #typeCombo {
                width: 100%;
            }

            #importPicker {
                width: calc(50% - 2px);
                margin-right: 2px;
            }

            #docPicker {
                width: 50%;
            }

            #patCombo {
                width: calc(60% - 2px);
                margin-right: 2px;
            }

            #NissTextField {
                width: 40%;
            }

            .panel {
                display: flex;
                flex-direction: column;
                width: calc(50% - 2px);
                margin-bottom: 24px;
                margin-top: 24px;
            }

            .modal-button {
                --paper-button-ink-color: var(--app-secondary-color);
                background-color: var(--app-secondary-color);
                color: var(--app-text-color);
                font-weight: 700;
                font-size: 14px;
                height: 40px;
                min-width: 100px;
                padding: 10px 1.2em;
                text-transform: uppercase;
            }

            .modal-button--cancel {
                background: transparent;
                border: 1px solid var(--app-background-color-dark);
            }

            #import-buttons {
                display: flex;
                flex-flow: row;
                padding-bottom: 24px;
                min-width: 250px;
            }

            #doc-list {
                flex-grow: 1;
            }

            vaadin-grid.material {

                font-family: Roboto, sans-serif;
                --divider-color: rgba(0, 0, 0, var(--dark-divider-opacity));

                --vaadin-grid-cell: {
                    padding: 8px;
                };

                --vaadin-grid-header-cell: {
                    height: 64px;
                    color: rgba(0, 0, 0, var(--dark-secondary-opacity));
                    font-size: var(--font-size-large);
                };

                --vaadin-grid-body-cell: {
                    height: 48px;
                    color: rgba(0, 0, 0, var(--dark-primary-opacity));
                    font-size: var(--font-size-normal);
                };

                --vaadin-grid-body-row-hover-cell: {
                    background-color: var(--paper-grey-200);
                };

                --vaadin-grid-body-row-selected-cell: {
                    background-color: var(--paper-grey-100);
                };

                --vaadin-grid-focused-cell: {
                    box-shadow: none;
                    font-weight: bold;
                };
            }

            vaadin-grid.material .cell {
                overflow: hidden;
                text-overflow: ellipsis;
                padding-right: 0;
            }

            vaadin-grid.material .cell.last {
                /*padding-right: 24px;*/
            }

            #visual-panel {
                min-width: 600px;
                width: calc(10% - 2px);
                /*height: 100%*/
                background-color: rgb(113, 135, 146);
                padding: 0;
            }

            .img-container {
                height: 100%; width: 100%;
                top: 0; left: 0;
                margin: 0; padding: 20px;
                align-self: center;
                display:flex;
                justify-content: center;
                align-items: center;
            }

            .img-container img {
                height: 100%;
                max-width: 600px;
            }

            pdf-element {
                max-width: 600px;
                height: 100%;
                --max-pdf-viewer-height: calc(var(--main-height) - 120px);
                --max-pdf-viewer-width: 600px;
            }

            .modalDialog {
                display: flex;
                flex-direction: column;
                min-height: 300px;
                height: 200px;
                min-width: 400px;
                width: 600px;
            }

            .modalDialogContent {
                height: 250px;
                width: auto;
                margin: auto;
            }

            .modal-title {
                background: var(--app-background-color-dark);
                margin-top: 0;
                padding: 16px 24px;
            }

            .dialogContainer {
                position: absolute;
                width: 100%;
                height: 100%;
                top: 0;
                left: 0;
                background-color: rgba(0, 0, 0, .3);
                z-index: 10;
                text-align: center;
            }

            .dialogButtons {
                position: absolute;
                bottom: 40px;
                margin: 0;
                width: 100%;
                text-align: center;
                padding: 0;
            }

            .dialogButtons .modal-button {
                --paper-button-ink-color: var(--app-secondary-color);
                background-color: var(--app-secondary-color);
                color: var(--app-text-color);
                font-weight: 700;
                font-size: 14px;
                height: 40px;
                min-width: 100px;
                padding: 10px 1.2em;
                text-transform: uppercase;
            }

            .dialogButtons .modal-button.grey {
                --paper-button-ink-color: var(--app-background-color-dark);
                background-color: var(--app-background-color-dark);
            }

            .m-t-50 {
                margin-top: 50px !important;
            }

            .m-t-20 {
                margin-top: 20px !important;
            }

            .small {
                --iron-icon-height: 16px;
                --iron-icon-width: 16px;
            }

        </style>
        <template is="dom-if" if="[[_bodyOverlay]]">
            <div class="dialogContainer"></div>
        </template>
        <paper-dialog id="upload-dialog" always-on-top="true" no-cancel-on-outside-click no-cancel-on-esc-key>
            <div id="list-panel" class="panel">
                <div id="import-buttons">
                    <div id="upload-button">
                        <vaadin-upload id="vaadin-upload" no-auto files="{{files}}" accept="image/jpeg,application/pdf"
                                       form-data-name="attachment"></vaadin-upload>
                    </div>
                    <template is="dom-if" if="[[_hasScanners(hasElectron,scannerList)]]">
                        <div class="buttons" id="scan-button">
                            <paper-button class="modal-button" on-tap="_launchScan" disabled="[[isScanning]]">
                                [[localize('scan','Scan',language)]]
                            </paper-button>
                        </div>
                    </template>
                </div>
                <vaadin-grid id="doc-list" class="material" items="[[docList]]" active-item="{{selectedDoc}}">
                    <vaadin-grid-column flex-grow="0">
                        <template class="header">
                            <div class="cell frozen">[[localize('type-doc','Type',language)]]</div>
                        </template>
                        <template>
                            <template is="dom-if" if="[[!item.isScanned]]">
                                <iron-icon icon="icons:file-upload"></iron-icon>
                            </template>
                            <template is="dom-if" if="[[item.isScanned]]">
                                <iron-icon icon="hardware:scanner"></iron-icon>
                            </template>
                        </template>
                    </vaadin-grid-column>
                    <vaadin-grid-column flex-grow="2">
                        <template class="header">
                            <div class="cell frozen">[[localize('title-doc','Titre',language)]]</div>
                        </template>
                        <template>[[item.title]]</template>
                    </vaadin-grid-column>
                    <vaadin-grid-column flex-grow="0">
                        <template class="header">
                            <div class="cell frozen">[[localize('del','Delete',language)]]</div>
                        </template>
                        <template>
                            <paper-button on-tap="_deleteItem">
                                <iron-icon icon="icons:close"></iron-icon>
                            </paper-button>
                        </template>
                    </vaadin-grid-column>
                </vaadin-grid>
            </div>
            <div id="visual-panel" class="panel">
                <template is="dom-if" if="[[selectedDoc]]">
                    <template is="dom-if" if="[[!isPdf]]">
                        <div class="img-container">
                            <img src="[[selectedData]]" alt=""/>
                        </div>
                    </template>
                    <template is="dom-if" if="[[isPdf]]">
                        <pdf-element fit-height id="viewer" src="[[selectedData]]"></pdf-element>
                    </template>
                </template>
            </div>
            <div id="form-panel" class="panel">
                <div id="form">
                    <h2>[[localize('upl_fil','Upload files',language)]]<span
                            class="extra-info">(PDF, images and videos)</span></h2>
                    <div class="input-form">
                        <vaadin-text-field id="importTextField"
                                           label="[[localize('docTitle','Titre du document',language)]]"
                                           value="{{selectedDoc.title}}"></vaadin-text-field>
                    </div>
                    <div class="input-form">
                        <vaadin-date-picker id="importPicker"
                                            label="[[localize('import_date','Date d\'importation',language)]]"
                                            value="{{selectedDoc.importDate}}" i18n="[[i18n]]"
                                            disabled></vaadin-date-picker>
                        <vaadin-date-picker id="docPicker" label="[[localize('doc_date','Date du document',language)]]"
                                            value="{{selectedDoc.docDate}}" i18n="[[i18n]]"></vaadin-date-picker>
                    </div>
                    <div class="input-form">
                        <vaadin-combo-box id="hcpCombo" filtered-items="[[listHcp]]"
                                          on-filter-changed="_filterHcpChanged" item-label-path="name"
                                          item-value-path="id" label="[[localize('persphysicianRole','Recipient',language)]]"
                                          value="{{selectedDoc.hcp}}">
                        </vaadin-combo-box>
                    </div>
                    <div class="input-form">
                        <vaadin-combo-box id="typeCombo" filtered-items="[[listType]]" item-label-path="name"
                                          item-value-path="code"
                                          label="[[localize('type-doc','Type de document',language)]]"
                                          value="{{selectedDoc.type}}">
                        </vaadin-combo-box>
                    </div>
                    <div class="input-form">
                        <vaadin-combo-box id="patCombo" filter="{{filterPatient}}"
                                          label="[[localize('pat-name','Nom du patient',language)]]"
                                          filtered-items="[[listPat]]" item-label-path="name" item-value-path="id"
                                          value="{{selectedDoc.patientId}}"
                                          disabled="{{patientDisabled}}"></vaadin-combo-box>
                        <vaadin-text-field id="NissTextField" label="[[localize('ssin','NISS',language)]]"
                                           value="{{selectedDoc.patientSsin}}"
                                           disabled="{{patientDisabled}}"></vaadin-text-field>
                    </div>
                </div>
                <div class="buttons" id="form-buttons">
                    <paper-button class="modal-button" on-tap="_saveDocuments" disabled="[[!selectedDoc]]">
                        [[localize('save','Enregistrer',language)]]
                    </paper-button>
                    <paper-button class="modal-button modal-button--cancel" on-tap="close">
                        [[localize('clo','Close',language)]]
                    </paper-button>
                </div>
            </div>
            <div id="drag-drop-layer" class="dragDropLayer"></div>
        </paper-dialog>
        <paper-dialog class="modalDialog" id="error-message-box" no-cancel-on-outside-click no-cancel-on-esc-key always-on-top>
            <h2 class="modal-title">
                <iron-icon icon="icons:warning"></iron-icon>
                [[localize('warning','Warning',language)]]
            </h2>
            <div class="modalDialogContent m-t-50">
                <h3 class="textAlignCenter">
                    [[errorTitle]]
                </h3>
                <p class="textAlignCenter m-t-20">
                    [[errorMessage]]: [[errorDetail]]
                </p>
            </div>
            <div class="dialogButtons">
                <paper-button class="modal-button modal-button--cancel" dialog-dismiss>
                    [[localize('clo','Close',language)]]
                </paper-button>
            </div>
        </paper-dialog>
    </template>
    <script>
        import _ from 'lodash/lodash';
        import moment from 'moment/src/moment';

        class HtUploadDialog extends Polymer.TkLocalizerMixin(Polymer.Element) {
            static get is() {
                return 'ht-upload-dialog';
            }

            static get properties() {
                return {
                    api: {
                        type: Object,
                        // observer: "apiReady"
                        noReset: true
                    },
                    doc: {
                        type: Boolean,
                        value: true
                    },
                    user: {
                        type: Object,
                        observer: "_userChanged"
                    },
                    _bodyOverlay: {
                        type: Boolean,
                        value: false
                    },
                    _dialogOverlay: {
                        type: Boolean,
                        value: false
                    },
                    patient: {
                        type: Object,
                        observer: "_patientChanged"
                    },
                    docList: {
                        type: Array,
                        value: () => []
                    },
                    selectedDoc: {
                        type: Object
                    },
                    files: {
                        type: Array
                    },
                    isLoadingDoc: {
                        type: Boolean,
                        value: false
                    },
                    isScanning: {
                        type: Boolean,
                        value: false
                    },
                    documentMetas: {
                        type: Object,
                        value: null
                    },
                    selectedScanner: {
                        type: String,
                        value: ""
                    },
                    scannerColor: {
                        type: Boolean,
                        value: false
                    },
                    scannerDuplex: {
                        type: Boolean,
                        value: true
                    },
                    scannerList: {
                        type: Array,
                        value: () => []
                    },
                    hasElectron: {
                        type: Boolean,
                        value: false,
                        observer: '_hasElectronChanged'
                    },
                    listHcp: {
                        type: Array,
                        value: () => []
                    },
                    listPat: {
                        type: Array,
                        value: () => []
                    },
                    filterPatient: {
                        type: String,
                        value: ""
                    },
                    listType: {
                        type: Array,
                        value: () => []
                    },
                    selectedData: {
                        type: Object,
                        value: null
                    },
                    isPdf: {
                        type: Boolean,
                        value: false
                    },
                    patientDisabled: {
                        type: Boolean,
                        value: false
                    },
                };
            }

            static get observers() {
                return [
                    'apiReady(api,user,opened)',
                    '_filesChanged(files.*)',
                    "_selectedDocChanged(selectedDoc.*)",
                    "_isInvalid(selectedDoc.*)",
                    "_filterPatChanged(filterPatient)",
                    "_patientIdChanged(selectedDoc.patientId)",
                    "_patientNissChanged(selectedDoc.patientSsin)",
                ];
            }

            constructor() {
                super();
            }

            ready() {
                super.ready();
                let uploadDialog = this.shadowRoot.querySelector('#upload-dialog');
                let dragDropLayer = this.shadowRoot.querySelector('#drag-drop-layer');
                let errorDialog = this.shadowRoot.querySelector('#error-message-box');

                uploadDialog.addEventListener('dragenter', () => {
                    dragDropLayer.style.visibility = 'visible';
                });
                dragDropLayer.addEventListener('dragenter', (e) => {
                    e.dataTransfer.dropEffect = 'copy';
                    e.preventDefault();
                });
                dragDropLayer.addEventListener('dragover', (e) => {
                    e.dataTransfer.dropEffect = 'copy';
                    e.preventDefault();
                });
                dragDropLayer.addEventListener('dragleave', () => {
                    dragDropLayer.style.visibility = "hidden";
                });
                dragDropLayer.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dragDropLayer.style.visibility = "hidden";
                    let target = this.shadowRoot.querySelector('vaadin-upload');
                    target && target._onDrop(e);
                });
            }

            apiReady() {
                this.api.isElectronAvailable().then(electron => this.set("hasElectron", electron)).catch(error => console.log(error));
                let exclusions = [
                    "medicaladvisoragreement",
                    "bvt-sample",
                    "clinicalpath",
                    "ecare-safe-consultation",
                    "ecare-tardis-consultation",
                    "perinatal",
                    "population-based-screening",
                    "medicationschemeelement",
                    "vaccinationschemeelement",
                    "genericregistryentry",
                    "ebirth-baby-medicalform",
                    "ebirth-mother-medicalform",
                    "intervention",
                    "applicationlink",
                    "ebirth-baby-notification",
                    "ebirth-mother-notification",
                    "child-prevention",
                    "radiationexposuremonitoring",
                    "treatmentsuspension",
                    "telemonitoring"
                ];

                this.api.code().findPaginatedCodes('be', 'CD-TRANSACTION', '')
                    .then(results => this.set("listType",  _.orderBy(results.rows.filter(r => !exclusions.includes(r.code)).map(result => {
                        return {
                            code: result.code,
                            name: this.localize('cd-transaction-' + result.code, result.code, this.language)
                        }
                    }), ['name'], ['asc'])))
                    .catch(error => console.log(error));
                console.log('ht-upload-dialog ready');
            }

            _hasElectronChanged() {
                if (!this.hasElectron) return;
                Promise.all([fetch("http://localhost:16042/scanning", {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({
                        request: "list"
                    })
                }), fetch('http://localhost:16042/getPrinterSetting', {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json; charset=utf-8"
                    },
                    body: JSON.stringify({
                        userId: this.user.id
                    })
                })
                ]).then(response => Promise.all(response.map(rep => rep.json()))).then(([data, settings]) => {
                    if (!data.ok) return;
                    const scanner = settings && settings.data && settings.data !== 'error' && JSON.parse(settings.data).find(set => set.type === "scanner")
                    this.set("selectedScanner", scanner && data.data.all.find(scan => scan.id === scanner.printer || scan.label === scanner.printer) ? scanner.printer : data.data.default.id)
                    this.set("scannerList", data.data.all)
                    this.set("scannerColor", scanner.color)
                    this.set("scannerDuplex", scanner.duplex)
                })
            }

            _updateView() {
                let type = _.toLower(this.selectedDoc.extension);
                let base64 = btoa([].reduce.call(new Uint8Array(this.selectedDoc.fileBlob), (p, c) => p + String.fromCharCode(c), ''));

                if (type === 'jpeg' || type === 'jpg' || type ==="PNG" || type ==="png") {
                    this.set('isPdf', false);
                    this.set('selectedData', 'data:image/jpeg;base64,' + base64);
                } else if (type === 'tif' || type === 'tiff') {
                    this.set('isPdf', false);
                    this.set('selectedData', 'data:image/tiff;base64,' + base64);
                } else if (type === 'pdf') {
                    this.set('isPdf', true);
                    this.set('selectedData',base64);
                    // setTimeout(() => this.shadowRoot.querySelector("#viewer").zoomFit(), 1000)
                }
            }

            _selectedDocChanged() {
                if (!this.selectedDoc) {
                    this.set('isPdf', false);
                    this.set('selectedData', null);
                    return;
                }
                console.log("selected doc changed =", this.selectedDoc)

                if (!this.listHcp.find(hcp => this.selectedDoc.hcp === hcp.id)) {
                    this.api.hcparty().getHealthcareParty(this.user.healthcarePartyId).then(tempHcp => {
                        this.push("listHcp", {
                            id: tempHcp.id,
                            name: tempHcp.name || tempHcp.firstName + " " + tempHcp.lastName || tempHcp.id
                        })
                    })
                }

                if (this.patient)
                    this._patientChanged();
                else {
                    this.api.patient().filterByWithUser(this.user, null, null, 50, null, null, true, {
                        filter: {
                            '$type': 'PatientByHcPartyNameContainsFuzzyFilter',
                            'healthcarePartyId': this.selectedHcp,
                            'searchString': this.filterPatient
                        }
                    })
                    .then(pats => pats.rows.map(pat => this._pushDistinctPatient("listPat", pat)))
                }
                this.$['doc-list'].clearCache()
                this._updateView();
            }

            _userChanged() {
                if (!this.user) return;
                this.api.hcparty().getHealthcareParty(this.user.healthcarePartyId).then(tempHcp => {
                    this.push("listHcp", {
                        id: tempHcp.id,
                        name: tempHcp.name || tempHcp.firstName + " " + tempHcp.lastName || tempHcp.id
                    })
                })
            }

            _wrapPatient(patient) {
                return {
                    id: patient.id,
                    name: patient.firstName + " " + patient.lastName || patient.id,
                    ssin: patient.ssin
                };
            }

            _pushDistinctPatient(listPath, patient) {
                if (!patient || !patient.id) return;
                if (this.get(listPath).find(item => item.id === patient.id)) return;
                this.push(listPath, this._wrapPatient(patient));
            }

            _patientChanged() {
                if (!this.patient || !this.selectedDoc) return;
                let pat = this._wrapPatient(this.patient);
                this._pushDistinctPatient("listPat", pat);
                this.set("selectedDoc.patientId", this.patient.id);
                this.shadowRoot.querySelector("#patCombo").selectedItem = pat;
            }

            _patientIdChanged() {
                if (!this.selectedDoc) return;
                let pat = this.listPat.find(pat => pat.id === this.selectedDoc.patientId) || {ssin: ""};
                pat.ssin !== this.selectedDoc.patientSsin && this.set("selectedDoc.patientSsin", pat.ssin);
            }

            _patientNissChanged() {
                if (!this.selectedDoc) return;
                if (!this.selectedDoc.patientSsin || !this._validSsin(this.selectedDoc.patientSsin)) return;
                const found = this.listPat.find(pat => pat.ssin === this.selectedDoc.patientSsin)
                if (found) {
                    this.selectedDoc.patientId !== found.id && this.set("selectedDoc.patientId", found.id)
                } else {
                    this.api.patient().filterByWithUser(this.user, null, null, 10, null, null, "desc", {
                        filter: {
                            '$type': 'PatientByHcPartyAndSsinFilter',
                            'healthcarePartyId': this.selectedHcp,
                            'ssin': this.selectedDoc.patientSsin
                        }
                    }).then(pats => {
                        pats.rows.map(pat => this._pushDistinctPatient("listPat", pat))
                        this.set("selectedDoc.patientId", this.listPat.find(pat => pat.ssin === this.selectedDoc.patientSsin).id)
                    })
                }
            }

            _filterHcpChanged(e) {
                if (!e.detail.value) return;
                this.api.hcparty().findByName(e.detail.value, null, null, 100, "desc").then(hcps => {
                    this.set("listHcp", hcps.rows.map(hcp => {
                        return {
                            id: hcp.id,
                            name: hcp.name || hcp.firstName + " " + hcp.lastName || hcp.id
                        }
                    }))
                })
            }

            _filterPatChanged(e) {
                if (!this.filterPatient || !this.selectedDoc) return;
                this.api.patient().filterByWithUser(this.user, null, null, 50, null, null, true, {
                    filter: {
                        '$type': 'PatientByHcPartyNameContainsFuzzyFilter',
                        'healthcarePartyId': this.user.healthcarePartyId,
                        'searchString': this.filterPatient
                    }
                }).then(pats => {
                    this.set("listPat", pats.rows.map(pat => {
                        return {
                            id: pat.id,
                            name: pat.firstName + " " + pat.lastName || pat.id,
                            ssin: pat.ssin
                        }
                    }))
                })
            }

            _validSsin(ssin) {
                return ssin && ssin.length > 9;
            }

            _hasScanners() {
                return this.hasElectron && this.scannerList && this.scannerList.length;
            }

            _isScannedFile(document) {
                return document.isScanned
            }

            _launchScan() {
                this.set("isScanning", true);
                let args = "-p " + this.selectedScanner + (this.scannerColor ? " -c color" : " -c bw") + (this.scannerDuplex ? " -d" : "");
                fetch("http://localhost:16042/scanning", {
                    method: "POST",
                    headers: {"Content-Type": "application/json"},
                    body: JSON.stringify({
                        request: "scan",
                        arguments: args,
                        scanner: this.selectedScanner
                    })
                })
                    .then(response => response.json())
                    .then(response => {
                        if (!response.ok) {
                            this.dispatchEvent(new CustomEvent("error-message", {
                                detail: {
                                    title: this.selectedScanner,
                                    message: 'err.scan.capture',
                                    detail: response.data
                                }, bubbles: true
                            }));
                            return;
                        }

                        let document = {
                            isScanned: true,
                            title: "scanned doc nÂ°" + this.docList.filter(doc => doc.isScanned).length + 1,
                            fileBlob: this.api.crypto().utils.base64toArrayBuffer(response.data.base64),
                            importDate: moment().format("YYYY-MM-DD"),
                            docDate: moment().format("YYYY-MM-DD"),
                            hcp: this.user.healthcarePartyId,
                            type: "",
                            extension: "pdf",
                            patientId: this.patient ? this.patient.id : "",
                            patientSsin: this.patient ? this.patient.ssin : ""
                        };
                        this.push("docList", document);
                        this.set("selectedDoc", document);
                    })
                    .finally(() => {
                        this.set("isScanning", false);
                    })
            }

            _encryptInfo(message, info) {
                if (!message.metas)
                    return Promise.reject('Invalid message structure');
                try {
                    return this.api.encryptDecryptFileContentByUserHcpIdAndDocumentObject("encrypt", this.user, message, this.api.crypto().utils.ua2ArrayBuffer(this.api.crypto().utils.text2ua(JSON.stringify(info))))
                        .then(encrypted => {
                            message.metas.cryptedInfo = btoa(String.fromCharCode.apply(null, new Uint8Array(encrypted)));
                            return message;
                        })
                } catch (error) {
                    return Promise.reject(error);
                }
            }

            _readFile(file) {
                return new Promise(function (resolve, reject) {
                    let reader = new FileReader();
                    reader.onload = function (e) {
                        resolve(e.target.result);
                    };
                    reader.onerror = reader.onabort = reject;
                    reader.readAsArrayBuffer(file);
                });
            }

            _filesChanged() {
                if (this.files.length === 0) return;
                let file = this.files.pop();
                let extension = _.toLower(file.name.split('.').pop());
                if (['pdf', 'jpg', 'jpeg', 'png'].includes(extension)) {
                    this._readFile(file).then((dataFile) => {
                        let document = {
                            isScanned: false,
                            importDate: moment().format("YYYY-MM-DD"),
                            docDate: moment().format("YYYY-MM-DD"),
                            hcp: this.user.healthcarePartyId,
                            title: file.name,
                            fileBlob: dataFile,
                            type: "",
                            extension: _.toLower(file.name.split('.').pop()),
                            patientId: this.patient ? this.patient.id : "",
                            patientSsin: this.patient ? this.patient.ssin : ""
                        };
                        this.push("docList", document);
                        this.set("selectedDoc", document);
                    });
                } else {
                    this.dispatchEvent(new CustomEvent('error-message', {
                        detail: {
                            title: file.name,
                            message: "err.document.invalidType"
                        }, bubbles: true
                    }));
                }
            }

            _reset() {
                this.set("docList", [])
                this.$['doc-list'].clearCache()
                this.set('files', []);
                this.set("selectedDoc", null)
            }

            _deleteItem(e) {
                if (e.model && e.model.item) {
                    let item = e.model.item;
                    this.set("docList", this.docList.filter(doc => doc !== item));
                    if (this.selectedDoc === item) {
                        this.set("selectedDoc", null)
                        this.set('isPdf', false);
                        this.set('selectedData', null);
                    }
                }
            }

            _isInvalid(document) {
                return _.trim(document.title) === "" || document.type === "" || document.docDate === "" || !document.fileBlob;
            }

            _saveDocuments() {
                if (this.docList.length === 0) return;
                let invalidDoc = this.docList.find(d => this._isInvalid(d));
                if (invalidDoc) {
                    let errors = []
                    errors.push(!invalidDoc.type && this.localize('doc-typ', 'Document type', this.language));
                    errors.push(!invalidDoc.docDate && this.localize('doc_date', 'Document date', this.language));
                    errors.push(!invalidDoc.title && this.localize('docTitle', 'Title', this.language));
                    errors.push(!invalidDoc.fileBlob && this.localize('file', 'File', this.language));
                    let errorDetail = errors.filter(item => !!item).join(', ');
                    this.dispatchEvent(new CustomEvent("error-message", {
                        detail: {
                            title: invalidDoc.title || 'Unknown',
                            message: 'err.document.missingField',
                            detail: errorDetail
                        }, bubbles: true
                    }));
                } else {
                    this.dispatchEvent(new CustomEvent('save-documents', {
                        detail: {
                            documents: this.docList
                        },
                        bubbles: true
                    }));
                }
            }

            open() {
                const vaadinUpload = this.$['vaadin-upload'];
                vaadinUpload.set('i18n.addFiles.many', this.localize('imp', 'Import', this.language))
                vaadinUpload.set('i18n.dropFiles.many', this.localize('uplabel', 'Drop files here...', this.language))
                this.set('files', []);
                this.set('_bodyOverlay', true)
                this.$['upload-dialog'].open();
                this._hasElectronChanged();
            }

            close() {
                this._reset()
                this.$['upload-dialog'].close();
                this.set('_bodyOverlay', false)
            }

            defaultSaveDocuments(e) {
                let messagesToSend = []
                let contactUpdated = null
                if (!(e && e.detail && e.detail.documents && e.detail.documents.length)) return;
                console.log("message to process ", e.detail.documents.length);
                Promise.all((e.detail.documents || []).map(doc => Promise.all([
                        this.api.user().findByHcpartyId(doc.hcp),
                        this.api.message().newInstance(this.user)])
                        .then(([user, msg]) => this.api.message().createMessage(_.merge(msg, {
                            transportGuid: "DOC:" + (doc.isScanned ? "SCAN" : "IMPORT") + ":IN",
                            recipients: [doc.hcp, (this.user.healthcarePartyId || (this.hcp && this.hcp.id) || "")],
                            recipientsType: "org.taktik.icure.entities.HealthcareParty",
                            metas: {
                                filename: doc.title,
                                importDate: doc.importDate,
                                documentDate: doc.docDate,
                                type: doc.type
                            },
                            toAddresses: [_.get(this.user, 'email', _.get(this.user, 'healthcarePartyId', "")), _.get(user, "email", doc.hcp)],
                            subject: "imported doc in message",
                            //@ToDo test on persphysician ==> traited or not
                            status: (doc.isScanned ? 1 << 24 : 0) | 1 << 1 | 1 << 25 | (doc.patientId ? 1 << 26 : 0)
                        })))
                        .then(msg => {
                            console.log("processing message ", msg.id);
                            let mimeType = _.toLower(doc.extension);
                            mimeType = mimeType === 'jpg' ? 'jpeg' : mimeType === 'tif' ? 'tiff' : mimeType;
                            let name = doc.title.includes("." + doc.extension) ? _.trim(doc.title) : _.trim(doc.title) + "." + doc.extension;
                            // name = name + " - " + moment(doc.docDate).format("DD/MM/YYYY");
                            return this.api.document().newInstance(this.user, msg, {
                                documentType: doc.type,
                                mainUti: this.api.document().uti(mimeType === "pdf" ? "application/pdf" : "image/" + mimeType),
                                name: name,
                                created: parseInt(moment(doc.docDate).format("x")) || new Date().getTime()
                            })
                                .then(newDoc => this.api.document().createDocument(newDoc))
                                .then(createdDoc => {
                                    doc.docId = createdDoc.id;
                                    return this.api.encryptDecryptFileContentByUserHcpIdAndDocumentObject("encrypt", this.user, createdDoc, doc.fileBlob)
                                })
                                .then(encryptedFileContent => this.api.document().setAttachment(doc.docId, null, encryptedFileContent))
                                .then(() => msg)
                        })
                        .then((msg) => {
                            if (!doc.patientId) {
                                console.log("no patient for message ", msg.id);
                                return this._encryptInfo(msg, [{}])
                            } else {
                                console.log("has patient for message ", msg.id);
                                return this.api.patient().getPatientWithUser(this.user, doc.patientId)
                                    .then(patient => this.api.register(patient, "patient"))
                                    .then(patient => this.api.contact().newInstance(this.user, patient, {
                                        created: parseInt(moment(doc.docDate).format("x")) || new Date().getTime(),
                                        modified: parseInt(moment(doc.docDate).format("x")) || new Date().getTime(),
                                        author: this.user.id,
                                        responsible: this.user.healthcarePartyId,
                                        subContacts: []
                                    }))
                                    .then(contact => {
                                        const svc = this.api.contact().service().newInstance(this.user, {
                                            content: _.fromPairs([[this.language, {
                                                documentId: doc.docId,
                                                stringValue: doc.title
                                            }]]),
                                            tags: [{type: 'CD-TRANSACTION', code: doc.type ? doc.type : 'report'}],
                                            label: 'imported document'
                                        });
                                        contact.services = [svc];
                                        const sc = {status: 64, services: [{serviceId: svc.id}]};
                                        contact.subContacts.push(sc);
                                        return this.api.contact().createContactWithUser(this.user, contact)
                                    })
                                    .then(contact => this.api.register(contact, "contact"))
                                    .then(contact => contactUpdated=contact)
                                    .then(contact => this._encryptInfo(msg, [{
                                        'patientId': doc.patientId,
                                        'isAssigned': true,
                                        'contactId': contact.id
                                    }]))
                            }
                        })
                        .then((msg) => this.api.message().modifyMessage(msg))
                        .catch((error) => console.log(error))
                ))
                    .then((values) => {
                        console.log("processed messages ", values.length)
                        messagesToSend = values
                    })
                    .catch((error) => console.log(error))
                    .finally(() => this.dispatchEvent(new CustomEvent("post-process", {detail : {messages : messagesToSend, contact : contactUpdated},bubbles: true})))
            }

            showErrorMessage(e) {
                if (e.detail && e.detail.title && e.detail.message) {
                    return setTimeout(() => {
                        console.log(e.detail.error);
                        this.set('errorTitle', e.detail.title);
                        this.set('errorMessage', this.localize(e.detail.message, e.detail.message, this.language));
                        e.detail.detail && this.set('errorDetail', e.detail.detail);
                        this.$["error-message-box"].open();
                    }, 200);
                }
            }
        }

        customElements.define(HtUploadDialog.is, HtUploadDialog);
    </script>
</dom-module>
